name: Build all tags (except blacklist) -> versions artifact (MicroPython injected, fake git only during compile)

on:
  workflow_dispatch:
  schedule:
    - cron: "0 2 * * *" # daily 02:00 UTC

permissions:
  contents: read

jobs:
  build_all_tags:
    runs-on: ubuntu-latest
    timeout-minutes: 360

    steps:
      - name: Checkout (full history + tags)
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Install build prerequisites (ISO + tools)
        run: |
          sudo apt-get update
          sudo apt-get install -y \
            expect git coreutils rsync \
            xorriso grub-pc-bin grub-common mtools nasm \
            build-essential bison flex libgmp3-dev libmpc-dev libmpfr-dev texinfo \
            libisl-dev wget tar xz-utils

      - name: Cache i686-elf toolchain
        uses: actions/cache@v4
        with:
          path: /opt/cross
          key: i686-elf-toolchain-v1

      - name: Build i686-elf toolchain (if not cached)
        run: |
          set -euo pipefail
          if [ -x /opt/cross/bin/i686-elf-gcc ]; then
            exit 0
          fi

          sudo mkdir -p /opt/cross
          sudo chown -R "$USER":"$USER" /opt/cross

          mkdir -p /tmp/toolchain
          cd /tmp/toolchain

          BINUTILS_VER=2.42
          GCC_VER=14.1.0

          wget -q https://ftp.gnu.org/gnu/binutils/binutils-${BINUTILS_VER}.tar.xz
          wget -q https://ftp.gnu.org/gnu/gcc/gcc-${GCC_VER}/gcc-${GCC_VER}.tar.xz

          tar -xf binutils-${BINUTILS_VER}.tar.xz
          tar -xf gcc-${GCC_VER}.tar.xz

          mkdir -p build-binutils
          cd build-binutils
          ../binutils-${BINUTILS_VER}/configure \
            --target=i686-elf \
            --prefix=/opt/cross \
            --with-sysroot \
            --disable-nls \
            --disable-werror
          make -j"$(nproc)"
          make install
          cd ..

          cd gcc-${GCC_VER}
          ./contrib/download_prerequisites
          cd ..

          mkdir -p build-gcc
          cd build-gcc
          ../gcc-${GCC_VER}/configure \
            --target=i686-elf \
            --prefix=/opt/cross \
            --disable-nls \
            --enable-languages=c \
            --without-headers
          make -j"$(nproc)" all-gcc all-target-libgcc
          make install-gcc install-target-libgcc

      - name: Add cross toolchain to PATH
        run: echo "/opt/cross/bin" >> "$GITHUB_PATH"

      - name: Prepare MicroPython source cache (for injection)
        run: |
          set -euo pipefail
          if [ ! -d /tmp/micropython-src/.git ]; then
            git clone --depth 1 https://github.com/micropython/micropython.git /tmp/micropython-src
          else
            cd /tmp/micropython-src
            git fetch --depth 1 origin master
            git reset --hard origin/master
          fi

      - name: Build every tag except blacklist (inject MicroPython, fake git only during compile)
        env:
          BLACKLIST: "v0.6-alpha"
          # Optional: patterns separated by semicolons, e.g. "*-alpha;*-rc*"
          BLACKLIST_PATTERNS: ""
        run: |
          set -euo pipefail

          # REAL git for tag listing / checkout
          git fetch --tags --force

          OUT_BASE="/tmp/versions"
          rm -rf "$OUT_BASE"
          mkdir -p "$OUT_BASE"

          # ---- Expect script (safe, minimal, answers menus) ----
          EXPECT_FILE="/tmp/run_build.expect"
          cat > "$EXPECT_FILE" <<'EOF'
          set timeout -1
          log_user 1
          spawn bash -lc "./build.sh"

          expect {
            # --- update checks / prompts (avoid hangs & repo mutation) ---
            -re "(?i)checking.*repository.*update" { send "\r"; exp_continue }
            -re "(?i)updates are available"        { send "n\r"; exp_continue }
            -re "(?i)show changes"                { send "n\r"; exp_continue }
            -re "(?i)update repository now"       { send "n\r"; exp_continue }
            -re "(?i)press.*enter"                { send "\r"; exp_continue }

            # --- commit build count menu (choose 3 = Never) ---
            -re "(?i)Commit build count to GitHub\\?" { send "3\r"; exp_continue }
            -re "(?i)#\\?"                             { send "3\r"; exp_continue }

            # --- architecture menu (your menu + prompt; choose 1) ---
            -re "(?i)Select target architecture, comma-separated choices" { exp_continue }
            -re "(?i)Enter choice" { send "1\r"; exp_continue }
            -re "(?i)choice:"      { send "1\r"; exp_continue }

            eof
          }
          EOF

          # ---- Fake git shim (only during compile) ----
          FAKEBIN="/tmp/fakebin"
          mkdir -p "$FAKEBIN"
          cat > "$FAKEBIN/git" <<'EOF'
          #!/usr/bin/env bash
          set -e
          case "${1:-}" in
            pull|fetch|clone|remote|ls-remote)
              echo "CI NOTICE: git $1 disabled during compile"
              exit 0
              ;;
            submodule)
              if [[ "${2:-}" == "update" ]]; then
                echo "CI NOTICE: git submodule update disabled during compile"
                exit 0
              fi
              exec /usr/bin/git "$@"
              ;;
            *)
              exec /usr/bin/git "$@"
              ;;
          esac
          EOF
          chmod +x "$FAKEBIN/git"

          mapfile -t TAGS < <(git tag -l | sort -V)

          should_skip () {
            local t="$1"
            for b in $BLACKLIST; do
              [[ "$t" == "$b" ]] && return 0
            done
            IFS=';' read -ra pats <<< "${BLACKLIST_PATTERNS}"
            for p in "${pats[@]}"; do
              [[ -n "$p" && "$t" == $p ]] && return 0
            done
            return 1
          }

          FAIL_COUNT=0

          for TAG in "${TAGS[@]}"; do
            if should_skip "$TAG"; then
              echo "Skipping blacklisted tag: $TAG"
              continue
            fi

            echo "========================================"
            echo "Building tag: $TAG"
            echo "========================================"

            git checkout -f "$TAG"
            git clean -fdx

            mkdir -p "$OUT_BASE/$TAG"

            if [[ ! -f "./build.sh" ]]; then
              echo "SKIP: build.sh not found on tag $TAG" | tee "$OUT_BASE/$TAG/build.log"
              continue
            fi
            chmod +x ./build.sh || true

            # Inject MicroPython source into ./micropython (NOT committed)
            rm -rf micropython
            mkdir -p micropython
            rsync -a --delete --exclude='.git' /tmp/micropython-src/ micropython/

            # Run compile:
            # - fake git only inside this command
            REAL_PATH="$PATH"
            set +e
            (
              PATH="$FAKEBIN:$REAL_PATH" \
              expect -f "$EXPECT_FILE"
            ) 2>&1 | tee "$OUT_BASE/$TAG/build.log"
            RC=${PIPESTATUS[0]}
            set -e
            export PATH="$REAL_PATH"

            # Collect ISO from repo root
            ISO_OK=0
            if [[ -f "./exocore.iso" ]]; then
              cp -v "./exocore.iso" "$OUT_BASE/$TAG/"
              ISO_OK=1
            else
              echo "WARNING: exocore.iso not found in repo root" | tee -a "$OUT_BASE/$TAG/build.log"
            fi

            # Mark build result correctly
            if [[ "$RC" -ne 0 || "$ISO_OK" -ne 1 ]]; then
              echo "BUILD FAILED (rc=$RC iso=$ISO_OK)" | tee -a "$OUT_BASE/$TAG/build.log"
              FAIL_COUNT=$((FAIL_COUNT+1))
            else
              echo "BUILD OK" | tee -a "$OUT_BASE/$TAG/build.log"
            fi
          done

          echo "Done. Failed builds: $FAIL_COUNT"
          # If you want the workflow to fail if ANY tag failed, uncomment:
          # [[ "$FAIL_COUNT" -eq 0 ]]

      - name: Upload versions artifact (always)
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: versions
          path: /tmp/versions
          if-no-files-found: warn
          retention-days: 90
