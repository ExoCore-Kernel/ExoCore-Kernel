name: Build all tags (script installs deps)

on:
  workflow_dispatch:
  schedule:
    - cron: "0 2 * * *" # daily 02:00 UTC

permissions:
  contents: read

jobs:
  build_all_tags:
    runs-on: ubuntu-latest
    timeout-minutes: 360

    steps:
      - name: Checkout (full history + tags)
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Install expect (needed to auto-type menu choice)
        run: |
          sudo apt-get update
          sudo apt-get install -y expect git coreutils

      - name: Build every tag except blacklist
        env:
          BLACKLIST: "0.6-alpha"
          # Optional patterns (bash globs) separated by semicolons, e.g. "*-alpha;*-rc*"
          BLACKLIST_PATTERNS: ""
          # Your script filename (change if different)
          BUILD_SCRIPT: "test_build.sh"
        run: |
          set -euo pipefail

          git fetch --tags --force
          mkdir -p versions

          # Get all tags
          mapfile -t TAGS < <(git tag -l | sort -V)

          should_skip () {
            local t="$1"
            for b in $BLACKLIST; do
              [[ "$t" == "$b" ]] && return 0
            done
            IFS=';' read -ra pats <<< "${BLACKLIST_PATTERNS}"
            for p in "${pats[@]}"; do
              [[ -n "$p" && "$t" == $p ]] && return 0
            done
            return 1
          }

          # Expect script:
          # - runs your script in --auto mode (installs deps + compiles, no QEMU)
          # - if arch/menu prompt appears, sends "2"
          cat > run_build.expect <<'EOF'
          set timeout -1
          log_user 1

          # Run your script. It calls apt-get itself, so run under sudo.
          spawn bash -lc "chmod +x ./$env(BUILD_SCRIPT) && sudo -E ./$env(BUILD_SCRIPT) --auto"

          expect {
            -re "(?i)architecture|arch.*select|select.*arch|choose.*arch|pick.*arch" {
              send "2\r"
              exp_continue
            }
            -re "(?i)choice:|enter.*choice|your.*choice" {
              send "2\r"
              exp_continue
            }
            eof
          }
          EOF

          FAIL_COUNT=0

          for TAG in "${TAGS[@]}"; do
            if should_skip "$TAG"; then
              echo "Skipping blacklisted tag: $TAG"
              continue
            fi

            echo "========================================"
            echo "Building tag: $TAG"
            echo "========================================"

            git checkout -f "$TAG"
            git clean -fdx

            # If the build script doesn't exist in some old tags, skip them cleanly
            if [[ ! -f "$BUILD_SCRIPT" ]]; then
              echo "SKIP: $BUILD_SCRIPT not found on tag $TAG"
              mkdir -p "versions/$TAG"
              echo "$BUILD_SCRIPT not found on this tag." > "versions/$TAG/build.log"
              continue
            fi

            mkdir -p "versions/$TAG"

            # Run build, always capture output
            set +e
            ( BUILD_SCRIPT="$BUILD_SCRIPT" expect -f run_build.expect ) 2>&1 | tee "versions/$TAG/build.log"
            BUILD_RC=${PIPESTATUS[0]}
            set -e

            # Collect ISO + logs produced by your script
            # Your script expects exocore.iso and writes test_build.log
            if [[ -f "exocore.iso" ]]; then
              cp -v "exocore.iso" "versions/$TAG/"
            fi
            if [[ -f "test_build.log" ]]; then
              cp -v "test_build.log" "versions/$TAG/"
            fi

            # Also collect any *.iso just in case older versions output somewhere else
            while IFS= read -r f; do
              cp -v "$f" "versions/$TAG/" || true
            done < <(find . -maxdepth 6 -type f -name "*.iso" -print | sort -u)

            if [[ "$BUILD_RC" -ne 0 ]]; then
              echo "BUILD FAILED for $TAG (exit $BUILD_RC)" | tee -a "versions/$TAG/build.log"
              FAIL_COUNT=$((FAIL_COUNT+1))
            else
              echo "BUILD OK for $TAG" | tee -a "versions/$TAG/build.log"
            fi
          done

          echo "Done. Failed builds: $FAIL_COUNT"
          # If you want the whole workflow to fail when any tag fails, uncomment:
          # [[ "$FAIL_COUNT" -eq 0 ]]

      - name: Upload versions artifact (always)
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: versions
          path: versions
          if-no-files-found: warn
          retention-days: 90
