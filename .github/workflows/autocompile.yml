name: Build all tags (except blacklist) -> versions artifact

on:
  workflow_dispatch:
  schedule:
    - cron: "0 2 * * *" # daily 02:00 UTC

permissions:
  contents: read

jobs:
  build_all_tags:
    runs-on: ubuntu-latest
    timeout-minutes: 360

    steps:
      - name: Checkout (full history + tags)
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      # Tools needed: expect for menu automation + deps for toolchain build
      - name: Install prerequisites
        run: |
          sudo apt-get update
          sudo apt-get install -y \
            expect git coreutils \
            build-essential bison flex libgmp3-dev libmpc-dev libmpfr-dev texinfo \
            libisl-dev wget tar xz-utils

      # Cache the cross compiler so you don't rebuild GCC every time
      - name: Cache i686-elf toolchain
        uses: actions/cache@v4
        with:
          path: /opt/cross
          key: i686-elf-toolchain-v1

      - name: Build i686-elf toolchain (if not cached)
        run: |
          set -euo pipefail

          if [ -x /opt/cross/bin/i686-elf-gcc ]; then
            echo "Toolchain already present (cached)."
            /opt/cross/bin/i686-elf-gcc --version | head -n 1 || true
            exit 0
          fi

          sudo mkdir -p /opt/cross
          sudo chown -R "$USER":"$USER" /opt/cross

          mkdir -p /tmp/toolchain
          cd /tmp/toolchain

          BINUTILS_VER=2.42
          GCC_VER=14.1.0

          echo "Downloading binutils ${BINUTILS_VER} and GCC ${GCC_VER}..."
          wget -q https://ftp.gnu.org/gnu/binutils/binutils-${BINUTILS_VER}.tar.xz
          wget -q https://ftp.gnu.org/gnu/gcc/gcc-${GCC_VER}/gcc-${GCC_VER}.tar.xz

          tar -xf binutils-${BINUTILS_VER}.tar.xz
          tar -xf gcc-${GCC_VER}.tar.xz

          echo "Building binutils..."
          mkdir -p build-binutils
          cd build-binutils
          ../binutils-${BINUTILS_VER}/configure \
            --target=i686-elf \
            --prefix=/opt/cross \
            --with-sysroot \
            --disable-nls \
            --disable-werror
          make -j"$(nproc)"
          make install
          cd ..

          echo "Preparing GCC prerequisites..."
          cd gcc-${GCC_VER}
          ./contrib/download_prerequisites
          cd ..

          echo "Building GCC (C only, no headers)..."
          mkdir -p build-gcc
          cd build-gcc
          ../gcc-${GCC_VER}/configure \
            --target=i686-elf \
            --prefix=/opt/cross \
            --disable-nls \
            --enable-languages=c \
            --without-headers
          make -j"$(nproc)" all-gcc
          make -j"$(nproc)" all-target-libgcc
          make install-gcc
          make install-target-libgcc

          echo "Toolchain installed:"
          /opt/cross/bin/i686-elf-gcc --version | head -n 1

      - name: Add cross toolchain to PATH
        run: echo "/opt/cross/bin" >> "$GITHUB_PATH"

      - name: Build every tag except blacklist
        env:
          # Add more tags here if needed
          BLACKLIST: "0.6-alpha"
          # Optional: patterns separated by semicolons, e.g. "*-alpha;*-rc*"
          BLACKLIST_PATTERNS: ""
        run: |
          set -euo pipefail

          git fetch --tags --force
          mkdir -p versions

          mapfile -t TAGS < <(git tag -l | sort -V)

          should_skip () {
            local t="$1"

            # Exact blacklist
            for b in $BLACKLIST; do
              [[ "$t" == "$b" ]] && return 0
            done

            # Pattern blacklist (optional)
            IFS=';' read -ra pats <<< "${BLACKLIST_PATTERNS}"
            for p in "${pats[@]}"; do
              [[ -n "$p" && "$t" == $p ]] && return 0
            done

            return 1
          }

          # Expect wrapper: runs ./build.sh and types "2" if it sees menu prompts
          cat > run_build.expect <<'EOF'
          set timeout -1
          log_user 1
          spawn bash -lc "./build.sh"
          expect {
            -re "(?i)Select target architecture" {
              send "2\r"
              exp_continue
            }
            -re "(?i)Enter choice \\[[0-9-]+\\]:" {
              send "2\r"
              exp_continue
            }
            -re "(?i)choice:|enter.*choice|your.*choice" {
              send "2\r"
              exp_continue
            }
            eof
          }
          EOF

          FAIL_COUNT=0

          for TAG in "${TAGS[@]}"; do
            if should_skip "$TAG"; then
              echo "Skipping blacklisted tag: $TAG"
              continue
            fi

            echo "========================================"
            echo "Building tag: $TAG"
            echo "========================================"

            git checkout -f "$TAG"
            git clean -fdx

            mkdir -p "versions/$TAG"

            if [[ ! -f "./build.sh" ]]; then
              echo "SKIP: build.sh not found on tag $TAG" | tee "versions/$TAG/build.log"
              continue
            fi

            chmod +x ./build.sh || true

            # Run build, capture log, don't stop the whole batch on one failure
            set +e
            ( expect -f run_build.expect ) 2>&1 | tee "versions/$TAG/build.log"
            BUILD_RC=${PIPESTATUS[0]}
            set -e

            # Collect ISO from repo root (your requirement)
            if [[ -f "./exocore.iso" ]]; then
              cp -v "./exocore.iso" "versions/$TAG/"
            else
              echo "WARNING: exocore.iso not found in repo root for $TAG" | tee -a "versions/$TAG/build.log"
            fi

            if [[ "$BUILD_RC" -ne 0 ]]; then
              echo "BUILD FAILED for $TAG (exit $BUILD_RC)" | tee -a "versions/$TAG/build.log"
              FAIL_COUNT=$((FAIL_COUNT+1))
              # Continue with next tag
            else
              echo "BUILD OK for $TAG" | tee -a "versions/$TAG/build.log"
            fi
          done

          echo "Done. Failed builds: $FAIL_COUNT"
          # If you want the workflow to fail if ANY tag failed, uncomment:
          # [[ "$FAIL_COUNT" -eq 0 ]]

      - name: Upload versions artifact (always)
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: versions
          path: versions
          if-no-files-found: warn
          retention-days: 90
