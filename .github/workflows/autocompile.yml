name: Build all tags (except blacklist) -> versions artifact (fake git only during compile)

on:
  workflow_dispatch:
  schedule:
    - cron: "0 2 * * *" # daily 02:00 UTC

permissions:
  contents: read

jobs:
  build_all_tags:
    runs-on: ubuntu-latest
    timeout-minutes: 360

    steps:
      - name: Checkout (full history + tags)
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Install prerequisites
        run: |
          sudo apt-get update
          sudo apt-get install -y \
            expect git coreutils \
            build-essential bison flex libgmp3-dev libmpc-dev libmpfr-dev texinfo \
            libisl-dev wget tar xz-utils

      - name: Cache i686-elf toolchain
        uses: actions/cache@v4
        with:
          path: /opt/cross
          key: i686-elf-toolchain-v1

      - name: Build i686-elf toolchain (if not cached)
        run: |
          set -euo pipefail
          if [ -x /opt/cross/bin/i686-elf-gcc ]; then
            echo "Toolchain already present (cached)."
            exit 0
          fi

          sudo mkdir -p /opt/cross
          sudo chown -R "$USER":"$USER" /opt/cross

          mkdir -p /tmp/toolchain
          cd /tmp/toolchain

          BINUTILS_VER=2.42
          GCC_VER=14.1.0

          wget -q https://ftp.gnu.org/gnu/binutils/binutils-${BINUTILS_VER}.tar.xz
          wget -q https://ftp.gnu.org/gnu/gcc/gcc-${GCC_VER}/gcc-${GCC_VER}.tar.xz

          tar -xf binutils-${BINUTILS_VER}.tar.xz
          tar -xf gcc-${GCC_VER}.tar.xz

          mkdir -p build-binutils
          cd build-binutils
          ../binutils-${BINUTILS_VER}/configure \
            --target=i686-elf \
            --prefix=/opt/cross \
            --with-sysroot \
            --disable-nls \
            --disable-werror
          make -j"$(nproc)"
          make install
          cd ..

          cd gcc-${GCC_VER}
          ./contrib/download_prerequisites
          cd ..

          mkdir -p build-gcc
          cd build-gcc
          ../gcc-${GCC_VER}/configure \
            --target=i686-elf \
            --prefix=/opt/cross \
            --disable-nls \
            --enable-languages=c \
            --without-headers
          make -j"$(nproc)" all-gcc
          make -j"$(nproc)" all-target-libgcc
          make install-gcc
          make install-target-libgcc

      - name: Add cross toolchain to PATH
        run: echo "/opt/cross/bin" >> "$GITHUB_PATH"

      - name: Build every tag except blacklist (fake git only during compile)
        env:
          # Add exact tag names here (space-separated)
          BLACKLIST: "v0.6-alpha"
          # Optional: patterns separated by semicolons, e.g. "*-alpha;*-rc*"
          BLACKLIST_PATTERNS: ""
        run: |
          set -euo pipefail

          # Ensure we have all tags (uses REAL git)
          git fetch --tags --force

          # Outputs OUTSIDE the repo so git clean can't delete them
          OUT_BASE="/tmp/versions"
          rm -rf "$OUT_BASE"
          mkdir -p "$OUT_BASE"

          # Expect script OUTSIDE the repo so git clean can't delete it
          EXPECT_FILE="/tmp/run_build.expect"
          cat > "$EXPECT_FILE" <<'EOF'
          set timeout -1
          log_user 1
          spawn bash -lc "./build.sh"
          expect {
            -re "(?i)Select target architecture" {
              send "2\r"
              exp_continue
            }
            -re "(?i)Enter choice" {
              send "2\r"
              exp_continue
            }
            -re "(?i)choice:|enter.*choice|your.*choice" {
              send "2\r"
              exp_continue
            }
            eof
          }
          EOF

          # Create fake git shim (but DO NOT activate it globally)
          FAKEBIN="/tmp/fakebin"
          mkdir -p "$FAKEBIN"
          cat > "$FAKEBIN/git" <<'EOF'
          #!/usr/bin/env bash
          set -e
          cmd="${1:-}"
          case "$cmd" in
            pull|fetch|clone)
              echo "CI NOTICE: git $cmd disabled during compile"
              exit 0
              ;;
            submodule)
              if [[ "${2:-}" == "update" ]]; then
                echo "CI NOTICE: git submodule update disabled during compile"
                exit 0
              fi
              exec /usr/bin/git "$@"
              ;;
            *)
              exec /usr/bin/git "$@"
              ;;
          esac
          EOF
          chmod +x "$FAKEBIN/git"

          mapfile -t TAGS < <(git tag -l | sort -V)

          should_skip () {
            local t="$1"
            for b in $BLACKLIST; do
              [[ "$t" == "$b" ]] && return 0
            done
            IFS=';' read -ra pats <<< "${BLACKLIST_PATTERNS}"
            for p in "${pats[@]}"; do
              [[ -n "$p" && "$t" == $p ]] && return 0
            done
            return 1
          }

          FAIL_COUNT=0

          for TAG in "${TAGS[@]}"; do
            if should_skip "$TAG"; then
              echo "Skipping blacklisted tag: $TAG"
              continue
            fi

            echo "========================================"
            echo "Building tag: $TAG"
            echo "========================================"

            # Checkout tag (uses REAL git)
            git checkout -f "$TAG"

            # Clean workspace for reproducible build
            git clean -fdx

            mkdir -p "$OUT_BASE/$TAG"

            if [[ ! -f "./build.sh" ]]; then
              echo "SKIP: build.sh not found on tag $TAG" | tee "$OUT_BASE/$TAG/build.log"
              continue
            fi

            chmod +x ./build.sh || true

            # Activate fake git ONLY for the compile command
            REAL_PATH="$PATH"
            set +e
            (
              PATH="$FAKEBIN:$REAL_PATH" \
              expect -f "$EXPECT_FILE"
            ) 2>&1 | tee "$OUT_BASE/$TAG/build.log"
            BUILD_RC=${PIPESTATUS[0]}
            set -e
            export PATH="$REAL_PATH"

            # Collect ISO from repo root (your requirement)
            if [[ -f "./exocore.iso" ]]; then
              cp -v "./exocore.iso" "$OUT_BASE/$TAG/"
            else
              echo "WARNING: exocore.iso not found in repo root for $TAG" | tee -a "$OUT_BASE/$TAG/build.log"
            fi

            if [[ "$BUILD_RC" -ne 0 ]]; then
              echo "BUILD FAILED for $TAG (exit $BUILD_RC)" | tee -a "$OUT_BASE/$TAG/build.log"
              FAIL_COUNT=$((FAIL_COUNT+1))
            else
              echo "BUILD OK for $TAG" | tee -a "$OUT_BASE/$TAG/build.log"
            fi
          done

          echo "Done. Failed builds: $FAIL_COUNT"
          # If you want the workflow to fail if ANY tag failed, uncomment:
          # [[ "$FAIL_COUNT" -eq 0 ]]

      - name: Upload versions artifact (always)
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: versions
          path: /tmp/versions
          if-no-files-found: warn
          retention-days: 90
